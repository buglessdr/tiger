#!/bin/sh
#
#     tiger - A UN*X security checking system
#     Copyright (C) 1993 Douglas Lee Schales, David K. Hess, David R. Safford
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2, or (at your option)
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#     Please see the file `COPYING' for the complete copyright notice.
#
# Linux/1/gen_mounts - 04/20/99
# Linux/2/gen_mounts - 04/20/99
# Updated by Advanced Research Corporation (R)
# Linux/2/gen_mounts - 11/19/2003 - Added ext3 and reiserfs as valid 
#     local filesystems (patch from Ryan Bradetich), also added xfs and jfs.
# Linux/2/gen_mounts - 03/21/2005 - Warn if the filesystem is not recognised
#     this is a fix for Tiger bug #7093 
# Linux/2/gen_mounts - 04/14/2005 - Add more filesystems and recognise the 
#     fact that users can define fallback filesystems (Debian Bug #304555 and
#     #302646)
# Linux/2/gen_mounts - 04/18/2005 - Fix to previous patch which introduced typos
# Linux/2/gen_mounts - 05/14/2005 - Added auto (Debian bug #305670), udev when
#     using on /dev (Debian bug #307802), capifs (Debian bug #307887), nfsd
#     (Debian bug #308585)
# Linux/2/gen_mounts - 07/22/2005 - Changed extraction from mount command
#     so it can cope with whitespaces in mount locations, added sanity check
#     and fix a bug that mangled $fs (Debian bug #315435)
# Linux/2/gen_mounts - 08/29/2005 - Added vzfs (VPS filesystem) to local fs, 
#     Savannah bug #14299
#
#-----------------------------------------------------------------------------
#

dirname()
{
  _path="$1"

  saveifs=$IFS
  IFS=/
  set X $_path
  IFS=$saveifs

  shift

  if [ $# -eq 1 ]; then
    _dirname='/'
  else
    _dirname=
    while [ $# -ne 1 ]
    do
      _dirname="$_dirname/$1"
      shift
    done
  fi
  
  echo "$_dirname"
}
  
LOCAL_ONLY=$1
CHKRO=$2

ronly()
{
  RO=1
  case "$1" in
    *[!a-zA-Z]ro[!a-zA-Z]*) RO=0
      ;;
  esac
  return $RO
}

localfs()
{
# Determine which filesystem is local, for filesystems valid for Linux
# read the mount(5), fstab(5) or Documentation/filesystems in the Linux
# kernel
  LOCAL=2
  # Valid local filesystems
  [ "$1" = "ext" ] && LOCAL=0
  [ "$1" = "ext2" ] && LOCAL=0
  [ "$1" = "ext3" ] && LOCAL=0
  [ "$1" = "auto" ] && LOCAL=0
  [ "$1" = "reiserfs" ] && LOCAL=0
  [ "$1" = "xfs" ] && LOCAL=0
  [ "$1" = "jfs" ] && LOCAL=0
  [ "$1" = "minix" ] && LOCAL=0
  [ "$1" = "xiafs" ] && LOCAL=0
  [ "$1" = "sysv" ] && LOCAL=0
  [ "$1" = "ufs" ] && LOCAL=0
  [ "$1" = "coherent" ] && LOCAL=0
  [ "$1" = "xenix" ] && LOCAL=0
  [ "$1" = "hpfs" ] && LOCAL=0
  [ "$1" = "rootfs" ] && LOCAL=0
  [ "$1" = "shm" ] && LOCAL=0
  [ "$1" = "tmpfs" ] && LOCAL=0
  [ "$1" = "auto" ] && LOCAL=0        
  [ "$1" = "vzfs" ] && LOCAL=0        # VPS virtual partition
  # Filesystems of other OS
  [ "$1" = "msdos" ] && LOCAL=1
  [ "$1" = "umsdos" ] && LOCAL=1
  [ "$1" = "vfat" ] && LOCAL=1
  [ "$1" = "ntfs" ] && LOCAL=1
  [ "$1" = "hfs" ] && LOCAL=1
  [ "$1" = "qnx4" ] && LOCAL=1
  [ "$1" = "udf" ] && LOCAL=1
  # Remotely mounted fs
  [ "$1" = "nfs" ] && LOCAL=1
  [ "$1" = "nfs4" ] && LOCAL=1
  [ "$1" = "nfsd" ] && LOCAL=1
  [ "$1" = "ncpfs" ] && LOCAL=1
  [ "$1" = "smbfs" ] && LOCAL=1
  [ "$1" = "coda" ] && LOCAL=1
  [ "$1" = "rpc_pipefs" ] && LOCAL=1
  # Skip these as they are virtual filesystems
  [ "$1" = "proc" ] && LOCAL=1
  [ "$1" = "devpts" ] && LOCAL=1
  [ "$1" = "usbfs" ] && LOCAL=1
  [ "$1" = "usbdevfs" ] && LOCAL=1
  [ "$1" = "devfs" ] && LOCAL=1
  [ "$1" = "sysfs" ] && LOCAL=1
  [ "$1" = "none" ] && LOCAL=1
  [ "$1" = "autofs" ] && LOCAL=1
  [ "$1" = "binfmt_misc" ] && LOCAL=1
  [ "$1" = "cramfs" ] && LOCAL=1
  [ "$1" = "ramfs" ] && LOCAL=1
  [ "$1" = "romfs" ] && LOCAL=1
  [ "$1" = "mqueue" ] && LOCAL=1
  [ "$1" = "sockfs" ] && LOCAL=1
  [ "$1" = "bdev" ] && LOCAL=1
  [ "$1" = "pipefs" ] && LOCAL=1
  [ "$1" = "eventpollfs" ] && LOCAL=1
  [ "$1" = "futexfs" ] && LOCAL=0
  # Other filesystems we don't support
  [ "$1" = "adfs" ] && LOCAL=1
  [ "$1" = "affs" ] && LOCAL=1
  [ "$1" = "afs" ] && LOCAL=1
  [ "$1" = "efs" ] && LOCAL=1
  [ "$1" = "iso9660" ] && LOCAL=1
  [ "$1" = "capifs" ] && LOCAL=1
  # Some special filesystems
  [ "$1" = "unknown" ] && [ "$2" = "/dev" ] && LOCAL=1
  # The rest we warn about
  if [ "$LOCAL" -eq 2 ] ; then
  	echo "--CONFIG-- [con010c] Filesystem '$1' used by '$2' is not recognised as a local filesystem" >&2
	LOCAL=1
  fi
  return $LOCAL
}

# If run directly do this, just in case:
[ -z "$GETFS" ] && GETFS=`which mount`
[ -z "$SED" ] && SED=`which sed`
[ -z "$BASENAME" ] && BASENAME=`which basename`

$GETFS  |
while read line
do
# $fs on $mtpoint type $fstype ($opts)
  PRINT=1
  fs=`echo $line | sed -e 's/ on.*$//'`
  mtpoint=`echo $line | sed -e 's/^.* on //' | sed -e 's/ type.*$//'`
  # Indent spaces in case we found any in the mount point
  mtpoint=`echo $mtpoint | sed -e 's/\([[:space:]]\)/\\\\\1/g'`
  fstype=`echo $line | sed -e 's/.* type \(.*\) (.*/\1/'`
  # Strip fallback filesystems
  fstype=`echo $fstype | $SED -e 's/,.*$//'`
  opts=`echo $line | sed -e 's/.* (\(.*\))$/\1/'`
  # Sanity check, do not proceed if the values are empty or if
  # we have not been able to parse the information properly
  [ -z "$fs" ] || [ -z "$mtpoint" ] || [ -z "$fstype" ] || [ -z "$opts" ] || \
  [ "$fs" = "$line" ] || [ "$mtpoint" = "$line" ] || \
  [ "$fstype" = "$line" ] || [ "$opts" = "$line" ] && \
  continue
  # TODO: warn in continuing?
  [ "$CHKRO" = "rw" ] && { ronly "$opts" && PRINT=0; }
  [ "$LOCAL_ONLY" = "local" ] && { localfs "$fstype" "$fs" || PRINT=0; }
  [ "$PRINT" = "1" ] && {
    dir=`dirname $fs`
    file=`$BASENAME $fs`
    rfs="$dir/r$file"
    echo "$mtpoint $fstype $fs"
  }
done

